{"remainingRequest":"/Users/haopeiwei/Documents/hpw/web-board/konva-board/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/haopeiwei/Documents/hpw/web-board/konva-board/src/components/module/h5canvas.vue?vue&type=style&index=0&id=2cb516c8&lang=less&scoped=true&","dependencies":[{"path":"/Users/haopeiwei/Documents/hpw/web-board/konva-board/src/components/module/h5canvas.vue","mtime":1599816203769},{"path":"/Users/haopeiwei/Documents/hpw/web-board/konva-board/node_modules/css-loader/dist/cjs.js","mtime":1594608463058},{"path":"/Users/haopeiwei/Documents/hpw/web-board/konva-board/node_modules/vue-loader/lib/loaders/stylePostLoader.js","mtime":1592981491866},{"path":"/Users/haopeiwei/Documents/hpw/web-board/konva-board/node_modules/postcss-loader/src/index.js","mtime":1591149286800},{"path":"/Users/haopeiwei/Documents/hpw/web-board/konva-board/node_modules/less-loader/dist/cjs.js","mtime":1597049187587},{"path":"/Users/haopeiwei/Documents/hpw/web-board/konva-board/node_modules/cache-loader/dist/cjs.js","mtime":1591588454175},{"path":"/Users/haopeiwei/Documents/hpw/web-board/konva-board/node_modules/vue-loader/lib/index.js","mtime":1592981491866}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCi5oNV9jYW52YXMgewogIC8vIHBvc2l0aW9uOiBhYnNvbHV0ZTsKICBib3JkZXI6IDFweCBzb2xpZCBncmVlbjsKICB0b3A6IDA7Cn0K"},{"version":3,"sources":["h5canvas.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyQA;AACA;AACA;AACA;AACA","file":"h5canvas.vue","sourceRoot":"src/components/module","sourcesContent":["<template>\n  <canvas class=\"h5_canvas\"></canvas>\n</template>\n<script>\nimport { debounce } from \"../../utils.js\";\nimport { fabric } from \"fabric\";\nconst PEN_URL =\n  \"https://img.vipkidstatic.com/beeschool/server/1594090400039/%E7%AC%94.png\";\n\nexport default {\n  props: {\n    width: {\n      type: Number,\n      default: 0\n    },\n    height: {\n      type: Number,\n      default: 0\n    },\n    mode: {\n      type: String,\n      default: \"\"\n    },\n    zIndex: {\n      type: Number,\n      default: 0\n    },\n    color: {\n      type: String,\n      default: \"red\"\n    },\n    item: {\n      type: Object,\n      default: () => {}\n    },\n    fc: {\n      type: Object\n    }\n  },\n  data() {\n    return {\n      canvas: null,\n      ctx: null,\n      points: [],\n      canDraw: false,\n      priviousPressure: 0,\n      beginPoint: null,\n      endPoint: null,\n      baseLineList: [6, 10, 15, 25],\n      historyList: []\n    };\n  },\n  watch: {\n    mode(newVal) {\n      if (!this.ctx) return;\n      if (newVal === \"pencil\") {\n        this.ctx.globalCompositeOperation = \"source-over\";\n        this.canvas.style.cursor = `url(\"${PEN_URL}\") 2 16, auto`;\n        // this.canvas.setCursor(`url(\"${PENCIL_URL}\") 2 16, auto`);\n      }\n      if (newVal === \"eraser\") {\n        this.ctx.globalCompositeOperation = \"destination-out\";\n        this.canvas.style.cursor = \"wait\";\n      }\n    }\n  },\n  mounted() {\n    if (!this.width || !this.height) return;\n    this.canvas = document.querySelector(\".h5_canvas\");\n    // console.log(this.canvas, this.width);\n    this.canvas.width = this.width;\n    this.canvas.height = this.height;\n    this.canvas.style.cursor = `url(\"${PEN_URL}\") 2 16, auto`;\n    this.ctx = this.canvas.getContext(\"2d\");\n    // console.log(\"...\", this.canvas, this.ctx);\n    this.ctx.globalCompositeOperation = \"source-over\";\n    this.ctx.lineCap = \"round\"; //设置线条的结束端点样式\n    this.ctx.lineJion = \"round\"; //设置两条线相交时，所创建的拐角类型\n    this.ctx.strokeStyle = this.color; // 线条颜色\n\n    // 注册事件\n    this.canvas.addEventListener(\n      \"pointerdown\",\n      (e) => {\n        // if (this.mode === \"eraser\") {\n        //   this.eraser(e);\n        // } else {\n        this.handledown(e);\n        // }\n      },\n      false\n    );\n    this.canvas.addEventListener(\n      \"pointerup\",\n      (e) => {\n        this.handleUp(e);\n        // this.debounceMethod(this);\n        // this.item.save(\"h5\", this.saveImageData());\n      },\n      false\n    );\n    this.canvas.addEventListener(\n      \"pointermove\",\n      (e) => {\n        this.handleMove(e);\n      },\n      false\n    );\n    this.canvas.addEventListener(\n      \"pointerleave\",\n      (e) => {\n        // if (this.mode === \"eraser\") {\n        // this.eraser(e);\n        // } else {\n        this.handleUp(e);\n        // this.saveImageData(\"llll\");\n        // }\n      },\n      false\n    );\n  },\n  methods: {\n    debounceMethod: debounce((that) => {\n      // 防抖\n      that.item.save(\"h5\", that.saveImageData());\n    }, 2000),\n    handleUp(e) {\n      if (!this.canDraw) return;\n      const { x, y, pressure } = this.getPos(e);\n      this.priviousPressure = pressure;\n      // this.points.push({ x, y });\n      this.points.push({ x, y, command: \"L\" });\n      if (this.points.length > 3) {\n        const lastTwoPoints = this.points.slice(-2);\n        const controlPoint = lastTwoPoints[0];\n        const endPoint = {\n          x: (lastTwoPoints[0].x + lastTwoPoints[1].x) / 2,\n          y: (lastTwoPoints[0].y + lastTwoPoints[1].y) / 2\n        };\n        this.drawPath(\n          this.beginPoint,\n          controlPoint,\n          endPoint,\n          ((this.priviousPressure + pressure) / 2) * this.baseLineList[0]\n        );\n        this.beginPoint = endPoint;\n      } else {\n        this.priviousPressure = pressure;\n      }\n      this.beginPoint = null;\n      this.canDraw = false;\n      this.points = [];\n    },\n    handledown(e) {\n      this.canDraw = true;\n      const { x, y, pressure } = this.getPos(e);\n      this.priviousPressure = pressure;\n      // this.points.push({ x, y });\n      this.points.push({ x, y, command: \"M\" });\n      this.beginPoint = { x, y };\n    },\n    handleMove(e) {\n      if (!this.canDraw) return;\n      const { x, y, pressure } = this.getPos(e);\n      this.priviousPressure = pressure;\n      // this.points.push({ x, y });\n      this.points.push({ x, y, command: \"L\" });\n      if (this.points.length > 3) {\n        const lastTwoPoints = this.points.slice(-2);\n        const controlPoint = lastTwoPoints[0];\n        const endPoint = {\n          x: (lastTwoPoints[0].x + lastTwoPoints[1].x) / 2,\n          y: (lastTwoPoints[0].y + lastTwoPoints[1].y) / 2\n        };\n        this.drawPath(\n          this.beginPoint,\n          controlPoint,\n          endPoint,\n          pressure * this.baseLineList[0]\n        );\n        this.beginPoint = endPoint;\n      }\n    },\n    getPos(e) {\n      const { pressure } = e;\n      return {\n        x: e.layerX,\n        y: e.layerY,\n        pressure\n      };\n    },\n    drawPath(beginPoint, controlPoint, endPoint, width) {\n      this.ctx.beginPath();\n      this.ctx.moveTo(beginPoint.x, beginPoint.y);\n      this.ctx.quadraticCurveTo(\n        controlPoint.x,\n        controlPoint.y,\n        endPoint.x,\n        endPoint.y\n      );\n      if (this.mode === \"eraser\") {\n        width = 15;\n        this.ctx.strokeStyle = \"#FFF\";\n      }\n      this.ctx.lineWidth = width;\n      this.ctx.stroke();\n      this.ctx.closePath();\n      let p = this.pathToCurve(this.points);\n      var path = new fabric.Path(p, {\n        fill: null,\n        stroke: this.color,\n        strokeWidth: width,\n        strokeLineCap: \"round\",\n        strokeLineJoin: \"round\",\n        evented: false,\n        hasControls: false,\n        hasBorders: false,\n        selectable: true,\n        isDrawingMode: false\n        // strokeStyle\n      });\n      this.fc.add(path);\n    },\n    saveImageData() {\n      let imgData = this.ctx.getImageData(\n        0,\n        0,\n        this.canvas.width,\n        this.canvas.height\n      );\n      return imgData;\n    },\n    putImageData(data) {\n      this.ctx.putImageData(data, 0, 0);\n    },\n    export() {\n      return this.canvas.toDataURL(\"image/jpeg\", 1.0);\n      // console.log(\"p\", p);\n    },\n    pathToCurve(path, controlPointsNum = 2) {\n      // M 开始 L 结束\n      let support = [\"M\", \"L\"];\n      let curve = { 2: \"Q\", 3: \"C\" };\n      let str = \"\";\n      for (let i = 0; i < path.length; i++) {\n        let { command, x, y } = path[i];\n        if (!support.includes(command)) {\n          throw new Error(`${command} is not support width start`);\n        }\n        if (i % controlPointsNum === 0) {\n          // 剩余点数不够组成曲线时使用L\n          let cmd =\n            i + controlPointsNum <= path.length ? curve[controlPointsNum] : \"L\";\n          str += ` ${cmd} ${x} ${y}`;\n        } else {\n          str += ` ${x} ${y}`;\n        }\n      }\n      return str;\n    }\n  }\n};\n</script>\n\n<style lang=\"less\" scoped>\n.h5_canvas {\n  // position: absolute;\n  border: 1px solid green;\n  top: 0;\n}\n</style>\n"]}]}